# 3.Context

> Context提供了一个无需为每层组件手动添加props，就能在组件树间进行数据传递的方法。



## 1.何时使用Context

> ```Context```设计目的是为了共享那些对于一个组件树而言是“全局”的数据。

### 1.1 传统写法

```javascript
import React from 'react'

function App() {
  return <Toolbar theme="dark" />
}

function Toolbar(props) {
  return (
    <div>
      <ThemButton theme={props.theme} />
    </div>
  )
}

class ThemButton extends React.Component {
  render() {
    return <Button theme={this.props.theme} />
  }
}

function Button(props) {
  return <button className={props.theme}>Props自上而下传递</button>
}

export default App

```

![image-20200421194124322](../images/image-20200421194124322.png)

### 1.2 使用context

```javascript
import React from 'react'

// 为当前theme创建一个context(默认值：light)
const ThemeContext = React.createContext('light')

class App extends React.Component {
  render() {
    // 使用一个Provider来将当前的 theme 传递给以下的组件树
    // 将“dark”作为当前值传递下去
    return (
      <ThemeContext.Provider value="dark">
        <Toolbar />
      </ThemeContext.Provider>
    )
  }
}

function Toolbar() {
  return (
    <div>
      <ThemedButton />
    </div>
  )
}

class ThemedButton extends React.Component {
  // 指定 contextType 读取当前 theme context
  static contextType = ThemeContext
  render() {
    return <Button theme={this.context} />
  }
}

function Button(props) {
  return <button className={props.theme}>Context</button>
}

export default App

```





## 2.使用Context之前的考虑

> Context主要应用场景在于很多不同层级的组件需要访问同样的一些数据。需要谨慎使用，因为这样会使得组件的**复用性变差**。

> **如果你只是想避免层层传递一些属性，[组件组合（component composition）](https://react.docschina.org/docs/composition-vs-inheritance.html)有时候是一个比 context 更好的解决方案。**

### 2.1 `组件组合`创建`Page`组件示例

![image-20200421233407762](../images/image-20200421233407762.png)

```javascript
import React from 'react'
import './Demo3.css'

function Feed(props) {
  return <div>hello {props.user.name}</div>
}

function Avatar(props) {
  return (
    <div>
      <img src={props.user.avatar} style={{ width: props.size }} />
    </div>
  )
}

function Link(props) {
  return (
    <a href={props.href} className="avatar-link">
      {props.children}
    </a>
  )
}

function NavigationBar(props) {
  return (
    <div>
      <ul>
        <li>
          <a href="#">Page1</a>
        </li>
        <li>
          <a href="#">Page2</a>
        </li>
      </ul>
      {props.children}
    </div>
  )
}

function PageLayout(props) {
  return (
    <div>
      <div className="navigation-bar">{props.topBar}</div>
      <div className="content">{props.content}</div>
    </div>
  )
}

function Page(props) {
  const user = props.user
  const content = <Feed user={user} />
  const topBar = (
    <NavigationBar>
      <Link href={user.permalink}>
        <Avatar user={user} size={props.avatarSize} />
      </Link>
    </NavigationBar>
  )

  return <PageLayout topBar={topBar} content={content} />
}

const App = () => {
  const user = {
    name: '小明',
    permalink: 'http://www.toutiao.com',
    avatar: 'http://placehold.it/50x50/FF5C60/000000?text=itcan',
  }
  return <Page user={user} avatarSize="50px" />
}

export default App

```

## 3.API

### 3.1 ```React.createContext```

- #### 语法：

```javascript
const MyContext = React.createContext(defaultValue);
```

> - 创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 `Provider` 中读取到当前的 context 值。
> - **只有**当组件所处的树中没有匹配到 Provider 时，其 `defaultValue` 参数才会生效。这有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 `undefined` 传递给 Provider 的 value 时，消费组件的 `defaultValue` 不会生效。

- #### 示例：

```javascript
// Context API

import React from 'react'

const MyContext = React.createContext('React')

function App() {
  return (
    <MyContext.Provider value="Vue">
      <FrontFramework />
    </MyContext.Provider>
  )
}

function FrontFramework() {
  return <Hello />
}

class Hello extends React.Component {
  // static contextType = MyContext

  render() {
    // return <div>Hello, {this.context}</div>
    return (
      <MyContext.Consumer>{value => <div>{value}</div>}</MyContext.Consumer>
    )
  }
}

export default App

```

![image-20200524174336979](../images/image-20200524174336979.png)

### 3.2 ```Context.Provider```

- #### 语法：

```javascript
<MyContext.Provider value={/* 某个值 */}>
```

> - 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。
>
> - Provider 接收一个 `value` 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。
>
> - 当 Provider 的 `value` 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 `shouldComponentUpdate` 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。



### 3.3 ```Class.contextType```



### 3.4 ```Context.Consumer```



### 3.5 ```Context.displayName```





## 4.示例

### 4.1 动态Context



###  4.2 在嵌套组件中更新Context



### 4.3 使用多个Context





## 5.注意事项



## 6.废弃的API

